---
search:
    keywords: ['proxy', '代理', '设计模式']

---


# 代理模式

## 1. 使用场景

需要在调用者和被调用者之间加入各种控制。

## 2. 实现举例

> 对于调用者来言，功能有方法的权限控制，以及方法的业务逻辑。但对于被调用者来言，只知道有业务逻辑部分，无需关注权限代码。

> 结论： 代理分离了权限关注点

> 对于调用者来言，功能有方法的业务逻辑，以及结果的缓存控制。但对于被调用者来言，只知道有业务逻辑部分，无需关注缓存代码。

> 结论： 代理分离了缓存关注点

* 对于调用者来言，功能有方法的事务控制，以及方法的业务逻辑。但对于被调用者来言，只知道有业务逻辑部分，无需关注事务代码。
> 说明： 代理分离了事务关注点

* 在方法的远程调用场景下，调用者只需像本地方法调用一样使用接口方法
> 说明： 代理分离了远程访问关注点

* 有些对象的创建较为昂贵，需要延迟实例化
> 说明： 代理分离了延迟实例化关注点

* 有些对象的生命周期与调用者不同，需要协调
> 说明： 代理分离了生命周期关注点


