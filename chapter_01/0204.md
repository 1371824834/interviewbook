---
search:
    keywords: ['innerclass']

---




#　为什么匿名内部类只能访问常量参数？
 
#　参考解答

```java
class A {
  public static void main(String[] args){
    int a = 10;
    final int b = a;
    Runnable r = new Runnable(){
      public void run(){
        System.out.println(b);
      }
    };
  }
}
```

如上例所示，javac会在编译时生成 A.class 和 A$1.class，它俩是一个平级的关系。
而A$1.class 想直接访问A.class中方法内的局部变量理论上是不行的，因此javac做了一点手脚，它编译生成A$1.class时，会将x作为A$1.class的成员变量，这个成员变量对我们程序员而言是“不可见的”，并且它的取值在一开始就被固定了。

上述代码的伪代码是：
```java
class A$1 implements Runnable{
  int val;
  public A$1(int val){
    this.val = val
  } 
  public void run() {
    System.out.println(this.val);
  }
}

class A {
  public static void main(String[] args){
    int a = 10;
    final int b = a;
    Runnable r = new A$1(b);
  }
}
```




3. 因为虽然匿名内部类在方法的内部，但实际编译的时候，内部类编译成Outer.Inner,这说明内部类所处的位置和外部类中的方法处在同一个等级上，外部类中的方法中的变量或参数只是方法的局部变量，这些变量或参数的作用域只在这个方法内部有效。因为编译的时候内部类和方法在同一级别上，所以方法中的变量或参数只有为final，内部类才可以引用。


---